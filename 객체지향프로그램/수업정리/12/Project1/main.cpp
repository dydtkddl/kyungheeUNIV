상속과 다형성

파생관계
1. I / O stream Inheritance
#include <iostream>
#include <fstream>

ios_base에서 ios를 만들고
ios 에서 istream 과 ostream을 만들고
istream에서는 iostream을 만든다.
istream에서 file에 대한 입력을 추가한게 ifstream
ostream에서 파일에 대한 출력을 추가한게 ofstream
iostream을 토대로 fstream을 만듦
iostream에서 stringstream을만듦
이런 상속관계.

void print(std::ostream & os, int n) {
	os << n << '\n;
}
int main() {
	print(std::cout, 35);
	std::ofstream
		fout("temp.txt");
	if (fout.good()) {
		print(fout, 36);
		fout.close();
	}
}
여기서 파라미터는 ostream으로 만들어놨는데
그 파생클래스인 ofstream이나 std::cout 이 들어가게 되면
그들이 제 구실을 할 수 있는지 그런 부분이 궁금해졌다


class B {
	// 디테일
};
class D : public B {
	//디테일
};
생성자, 소멸자, 논멤버함수, assignment operator,
virtual method ? 들은 상속되지 않는다

* 상속을 받은 파생클래스는 부모클래스의 메서드를 쓸수있다.

* 여러개의 클래스도 상속받을 수 있다

* *상속 지정자는 세가지로 나뉜다
1. private
2. public
3. protected
만약 private형태로 상속받으면, 기반 클래스의 멤버가 어떤
접근권한이었던지간에 모두 private접근권한의 멤버로 바꾼다
그러나 원래 private였던 멤버든 접근조차 할 수 없다.
그러니 private로 한번 상속받으면 또 그 클래스를 다시 다른
클래스에게 상속시킬때, 상속에 상속을 받을 일을 없애버린다.

만약 protected형태로 상속받으면, 기반클래스의 멤버의 접근권한이
private인 경우만 제외하고 모든 멤버의 접근권한을 최소 private로
만들어버린다.
private는 상속관계가 있는 같은 식구 파생클래스들에게만
허용을 하는 접근권한이다

public형태로 상속받으면, 기반클래스의 멤버의 접근권한을 그대로
유지하며 상속받는다.
-- -

자식클래스가 부모클래스의 멤버함수를 오버라이딩 했더라도
인스턴스.부모클래스::멤버함수()형태로 불러와서 이용할 수 있다.

상속받은 파생클래스에서, 생성될 때 부모클래스의 생성자를 실행시키려면
생성자코드에
Derived(int n1, int n2) : Base(n1), num2(n2) {
	위와 같은 형식으로 Base(n1)생성자를 호출해야한다.
}

파생클래스가 부모클래스보다 더 많은 멤버를 가질때
더 많은 멤버를 가진 파생클래스는 부모클래스 형태타입 객체 인스턴스에
재할당이 가능하지만
그 반대로, 더 많은 멤버를 가지는 파생클래스 형태타입 객체 인스턴스에
더 적은 멤버를 가지는 부모 클래스 형태타입 객체 인스턴스를 재할당
할 수 는 없다.

디폴트 생성자.
생성자를 하나도 정의하지 않을 때, 디폴트 생성자가 만들어진다.
이 경우 가진 멤버변수가 하나도 초기화가 되지 않아서
모두 가비지값이 할당된다
또 다른 의미의 디폴트 생성자
Base() : member1(0) {}; 이런식으로 생성자를 정의하면
Base b; 이런식으로 아무 인자도 넘기지 않고
b를 선언해도 자동으로 member1에 0이 할당된다.
만약 Base를 상속받는 파생클래스라면
생성자에서 기반클래스의 생성자를 호출하지 않아도된다
똑같이 Base()의 디폴트 생성자인 member1(0)이 실행되어서
member1이 0이 될것이다.

virtualfunction

부모클래스의 별칭 & 형태로 파생클래스타입의 인스턴스를 할당받았고
파생클래스에 있는 멤버함수를 사용하려고한다
그때, 컴파일러는 어쨌든 부모클래스의 형태로 받았으니
받아들인 형태를 기준삼아 그 인스턴스를 설정하기때문에
부모클래스에서 그 멤버함수를 찾게된다
만약 똑같은 이름의 함수가 부모클래스에 있었다면
그 파생클래스의 함수가 아닌 부모클래스의 함수가 실행될 것이고
부모클래스에 같은 이름의 함수가 존재하지도 않다면
그냥 오류가 날것이다
이때 비록 부모클래스의 형태로 할당을 받았다고 할지라도
그 형태를 보는게 아닌, 실제로 그 인스턴스 값이 가리키고 있는
곳의 클래스형태를 확인하게 한다면, 이와 같은 문제가 해결될 것이다.
그니까, 더 깊은 기반클래스의 타입으로 파생클래스의 인스턴스를
할당받더라도, 여전히 그 파생클래스인 것 처럼, 파생클래스의
함수들을 이용할 수 있게 하는것이다.
그걸 해주는 것이 virtualfunction이다.
실행시간에 함수의 호출을 연결해주는 것이 virtualfucntion이다.
이처럼 실행시간에 함수의 호출을 연결해주는 기능을 넣고싶다면
기반이 될 클래스의 그 해당 함수의 정의부 맨 앞부분에
virtual이라는 단어를 쓰면된다.
그러면 파생클래스에서 그 함수가 override가 되있고,
부모클래스의 타입으로 파생클래스 인스턴스를 받더라도
그 받아낸 클래스 타입을 쫒는게 아니라, 그 객체가 받은
실제인스턴스의 타입을 찾아 그 타입 클래스의 오버라이딩 된
함수를 원활하게 실행하게 한다.

그러니까 virtual함수는
1. 기반클래스의 함수를 파생클래스에서 override 하게되는 경우
2. 기반클래스 타입으로 파생클래스 인스턴스를 받더라도
파생클래스의 오버라이딩한 함수를 사용할 수 있게끔
함수의 호출을 실행시간에 연결해 주고 싶을 때
사용한다.
사용방법은
1. 기반클래스의 해당 함수 앞부분에 virtual선언
만약 virtual을 쓰지않은 기본형태면
기반클래스형으로 받은 파생클래스 인스턴스는
기반클래스형으로 받았기에, 오버라이딩된 함수를 사용하지 못한다.

객체의 포인터로 객체의 함수나 멤버로 접근하기 위해서는->를 쓴다.

특별히 기반클래스의 함수나 멤버를 호출하고 싶을 때는
그 인스턴스 예를들면 A인스턴스
A.Base클래스이름::멤버나멤버함수 이런식으로 사용한다.


소멸자.
소멸자는 프로그램이 끝나거나, 동적할당을 해제해줄 때
그  객체를 제거하는 작업을 해준다
제거되며 실행될 코드를 직접 짤 수 있다.


소멸자와 virtual
소멸자도 하나의 멤버함수이다
만약 기반클래스 타입으로 파생클래스 인스턴스의 주소나, 별칭을 받았을때
그것이 제거되는 순간에, virtual선언이 없다면
기반클래스의 소멸자가 실행된다.
그렇게되면 부모클래스는 사라졌지만 파생클래스에만 존재하는
멤버나 멤버함수들이 제대로 사라지지 않았기 때문에
메모리 누수를 야기한다
따라서 이런 기반클래스 타입으로 파생클래스인스턴스를 받은 경우에
파생클래스를 먼저 없애주고 기반클래스를 없애려면
기반클래스의 소멸자 앞에 virtual 선언을 꼭 해줘야한다.

파생클래스가 생성될때는 기반클래스 먼저 생성되고 파생클래스가 생성
파생클래스가 제거될때는 파생클래스 먼저 제거되고 기반클래스가 제거


이런 virtual선언을 사용할 때는
더 넓은 범위의 기반클래스 형태로 파생클래스 인스턴스를
별칭이나 포인터로 받아낼 때인데
굳이 이렇게 사용하지 않으면 되지 않을까 ?
보다 명확하게 파생클래스에서는 파생클래스 형태로 받아서
사용하면 되지 않을까 라는 생각을 해봤는데
잘 생각해보니 이런 경우가 있을 것 같았다
그 경우는 어떤 함수의 파라미터로, 어떤 클래스의 인스턴스를 받아내고 싶은데
특정 클래스를 기준으로 그 아래로 파생되는 모든 클래스들을
유연하게 받아내는 파라미터를 열어둬야 할 때이다.
그럴땐 가장 기반이 되는 클래스 형태의 파라미터를 만들어놔야한다.
이때, 전달되는 인자가 그것에서 더 파생된 파생클래스 인스턴스라면
기반클래스함수에 오버라이딩한 메서드를 사용할 때,
아무 virtual선언이 없다면 파라미터 타입인 기반클래스의 기반함수가
호출될 것이다
파생클래스가 오버라이딩한 메서드를 실행하게 하기위해서는 virtual선언이 필요할거같다고 생각했다


#ifndef AAA_H_INCLUDED
#define AAA_H_INCLUDED 
// 디테일
#endif 


virtual table ?
virtual선언된 함수를 가진 타입으로 인스턴스가 생성될 때,
virtual 테이블 배열을 생성한다.(해당 클래스가 가진 가상함수들의 포인터를 가지고있다)
클래스의 인스턴스는 이 배열을 참조해서 호출한 함수가
virtual함수인지를 판볋을 한다.
만약 virtual함수라면, 선언한 타입의 가상함수가 아닌
실행시점에 실제 객체타입의 가상함수가 호출이된다.
가상함수 호출에 대한 성능손실이 발생하더라도
다형성과 유연성을 제공하는 중요한 기능이다

virtual 선언 함수가 있는 클래스는
그 클래스가 생성될 때, virtual선언된 함수에 대한 정보를
virtual테이블에 저장한다.
어차피 그 파생클래스 인스턴스가 생성되려면
그 기반 클래스를 먼저 생성해야하므로
기반클래스에 virtual함수가 있었다면
파생클래스 인스턴스가 생성될 때, 그보다 먼저 기반클래스가
생성되며 virtual함수에 대한 정보를 virtual테이블에 기입했을 것이다.
그렇게 먼저 기록된 기반클래스의 virtual정보를 보고
파생클래스 자신이 오버라이딩 한 함수가
virtual테이블에 있는 함수인지 아닌지 확인을 한다음에
overriding한 함수를 추적해서 호출할것인지 아닌지를 결정한다

virtual 선언이 있는 클래스는
그 인스턴스가 생성될때 virtual테이블에 대한 포인터를 같이 가지고
생성되어서 그 사이즈가 더 크다.

--가상 함수는 다형성을 지원하기 위한 기능으로,
기반 클래스에서 선언되고 파생 클래스에서 오버라이딩됩니다.
가상 함수는 런타임에 실제 객체 타입에 맞는 함수가 호출되어
다형성을 구현합니다.
가상 함수는 가상 테이블을 통해 호출됩니다.


추상클래스 abstract class
기본적인 틀만 만들고 실제 인스턴스화 할 수 없는 클래스
순수 가상함수를 하나이상 포함하게되면
추상클래스가 됌.
순수가상함수는 가상함수지만
형식만 지정해두고 함수의 정의를 만들지 않은 가상함수
virtual double span() const = 0; 과 같이 = 0을 해줌.

근데 이걸 언제 쓸까 ? 왜쓸까 ? 얼핏보면 쓸모없어보인다
하지만 이는 쓸모가있다
왜냐하면 비슷한 특성을 가진 클래스들이지만
구분되는 클래스들을
하나의 폴더에 몰아담듯이
기반이되는 범주의 이름의 기반클래스를 만들 수 있기 때문이다
그 기반클래스는 하나의 범주가 되어준다
비록 인스턴스화 할 일이없더라도, 클래스의 상하관계에대한
명확한 이해를 돕기위해서 범주화를 한다는 것은 장점이다
그리고 그 추상적으로만 존재하는 범주화역할의 추상클래스에서
뻗어나가는 파생클래스들에서 공통적으로 쓰일 수 있는 멤버나
멤버함수가 있다면, 그것들을 미리
정의해 둘수도 있다.

추상클래스의 핵심은 범주화를 통한 집합화와 구조화라는 것이다.
추상 클래스는 인스턴스화할 수 없는 클래스로,
다형성과 인터페이스를 지원하는 기반 클래스입니다.
추상 클래스는 순수 가상 함수를 포함하며,
이를 상속받은 파생 클래스들은
반드시 해당 함수를 오버라이딩해야 합니다.


카피컨스트럭터

copy는 객체가 복사본 객체와 독립적으로 변경될 수 있게 해준다.
함수에서 reference로 전달되지 않고, copy형식으로
인자가 전달되게끔 할때
객체가 복사가 되는 메커니즘에 대한 구현이 필요하다
객체는 단순 변수와 달리 여러 멤버들이 있기에
멤버 by멤버로 복사가 되어야한다
이것을 깊은 복사라고 한다.
객체의 멤버를 복사할 때,
객체 내의 멤버도 독립적으로 복사하는 것을 의미(반대걔념 얕은복사)
그것이 구현이 되었을 때, 인자로 적절하게 copy가 되어
함수내로 그 인스턴스와 동일한 데이터가 들어갈 수 있을 것이고
함수 로직을 모두 끝내고 local스코프를 나올때
리턴값으로써 copy가 될때도 원활하게 작업된 산출물이 복사되어 나갈
수 있게된다
className(const className&)
className(const className&) = default // 혹은 아예 안쓸때
className(const className&) = delete

카피컨스트럭터를 하나라도 생성하면
디폴트 생성자가 만들어지지 않는다(생성자를 아예정의하지 않으면 안된다는 얘기)

Copy Assignment Operator
className & operator = (className)
className & operator = (const className&)
className & operator = (const className&) = default
className & operator = (const className&) = delete

copy constructor와 copy assignment 는 다르다
전자는 함수의 인자나 리턴값일 때 쓰이고
후자는 = 으로 할당연산을 할 떄 쓰인다.



다이나믹 캐스트
dynamic_cast<type>(expression)
실패시 nullptr반환
// 더 적은 멤버를 가진 클래스에서 더 많은 멤버를 가진 클래스로 캐스팅이 불가
// 실제로 가리키는 대상을 기준으로 함
// 다른 타입으로 동적으로 받더라도 ㄱㅊ