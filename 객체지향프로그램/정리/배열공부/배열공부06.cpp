//배열 05
/*new와 delete를 사용한 동적 메모리 할당*/
//지금까지는 고정길이 어레이를 컴파일시간에 초기화하는 배열을 다뤘다.
/* 고정길이 어레이는 어레이의 길이를 넘길 때, 길이를 컴파일시간에 지정된 변수가 아닌 상수를 이용해서 설정한다.
이번에는 new와 delete를 사용해서 동적 메모리를 할당해보려고 한다.
*/
/*C++은 세가지 기본 타입의 메모리할당을 지원한다.
1. 정적 메모리 할당
	정적 변수와 전역변수에 대해 발생한다.
	이러한 타입의 변수에 대한 메모리는 프로그램이 실행될 떄 
	한번 할당되며, 프로그램 수명 내내 지속한다.
2. 자동 메모리 할당
	함수 매개 변수와 지역변수에 대해 발생
	이러한 타입의 변수에 대한 메모리는 관련 블록을 입력할 떄 할당되고, 
	블록을 종료할 때 필요에 따라 여러번 해제된다.
3. 동적 메모리 할당

정적 및 자동 메모리 할당에는 두가지 공통점이 있다.
변수 / 배열의 크기는 컴파일 타임에 알아야한다.
메모리 할당 및 해제가 자동으로 수행된다.

즉, 배열의 길이를 미리 알고있어야하고 메모리 할당 및 해제를 사용자 마음대로 할 수가없다.
그래서 컴파일 시간에 변수의 최대 크기를 측정하고 충분하다고 가정하느 ㄴ것이다.
하지만 실제로 이렇게하면
낭비되는 메모리가 생길 수 있고, 그 이상으로 만에하나 변수에 요소가 추가되면 에러가 난다.
그리고 고정배열을 포함한 대부분의 일반변수는 스택이라는 메모리 영역에 할당되는데 보통 1메가바이트만을
스택크기로 가지기에, 스택오버플로우에 의해 운영체제가 프로그램을 종료한다.

단일 변수를 동적으로 할다앟려면 new연산자를 사용하면 된다
*/
#include <iostream>
int main() {
	int *ptr = new int;
	*ptr = 7;
	/*메모리를 동적으로 할당할 때
	1. 운영체제에 프로그램 사용을 위한 해당메모리 일부를 예약하도록 요청
	메모리 주소가 응용프로그램에 반환
	응용프로그램은 원하는대로 이 메모리를 사용
	메모리 사용을 완료하면 다시 운영체제로 반환
	프로그램 자체가 동적으로 할당된 메모리를 요청하고 처리하는 역할을 함*/
	int* ptr3 = new int(5);
	int* ptr2 = new int{ 5 };
	/*직접초기화와 달리 유니폼초기화는 형변환을 허용 x
	{}로 초기화하면 기본 초기화*/
	delete ptr;
	delete ptr2;
	/*delete연산자는 실제로 아무것도 삭제 x
	단순히 가리키는 메모리를 다시 운영체제로 반환.
	프로그램은 그 메모리에 접근할 권한을 잃게됌
	사실 그것뿐임.*/
	//std::cout << *ptr; // 댕글링 포인터.. 이미 운영체제에 회수된 메모리주소에 있는 값에 접근하려해서
	ptr = 0;
	//std::cout << *ptr;
	//널포인터가 가리키는 것은 없으므로 출력시 에러

	int* value = new (std::nothrow) int;
	if (!value) { // new 가 메모리를 할당하지 못헀을때 ,null포인터를 반환하므로.
		std::cout << "Could not allocate memory";
	};
	//아래처럼 하면 메모리 누수 있음
	/*
	int value = 5;
	int* ptr = new int; // allocate memory
	ptr = &value;       // old address lost, memory leak results*/
	//아래처럼 해야 메모리 누수가 없음
	int value2 = 5;
	int* ptr2 = new int; // allocate memory
	delete ptr2;         // return memory back to operating system
	ptr2 = &value2;       // reassign pointer to address of value
}